import { MultiFormatReader, RGBLuminanceSource, BinaryBitmap, HybridBinarizer, DecodeHintType, BarcodeFormat } from '@zxing/library';
import jsQR from 'jsqr';
// Generated by purs bundle 0.14.4
var PS = {};
(function ($PS) {
    // Generated by purs version 0.14.4
    "use strict";

    $PS["Data.Either"] = $PS["Data.Either"] || {};
    var exports = $PS["Data.Either"];
    var Left = function () {
        function Left(value0) {
            this.value0 = value0;
        };
        Left.create = function (value0) {
            return new Left(value0);
        };
        return Left;
    }();
    var Right = function () {
        function Right(value0) {
            this.value0 = value0;
        };
        Right.create = function (value0) {
            return new Right(value0);
        };
        return Right;
    }();
    exports.Left = Left;
    exports.Right = Right;
})(PS);
(function (exports) {
    "use strict";

    function scanBarcode(rgbaBuffer, width, height) {
        const hints = new Map();
        const formats = [BarcodeFormat.EAN_13, BarcodeFormat.EAN_8];
        hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);
        const reader = new MultiFormatReader(hints);
        const luminances = toGrayscaleBuffer(rgbaBuffer, width, height);
        const luminanceSource = new RGBLuminanceSource(luminances, width, height);
        const binaryBitmap = new BinaryBitmap(new HybridBinarizer(luminanceSource));
        return reader.decode(binaryBitmap);
    }

    function toGrayscaleBuffer(imageBuffer, width, height) {
        /*Zxing works with grayscale images. They use a green-favoring average:
        https://github.com/zxing/zxing/blob/be2c5bdd883f9f42e794e4b0e7e1b30f436fc0a7/core/src/main/java/com/google/zxing/RGBLuminanceSource.java#L42-L56
        */
        const size = width * height;
        let greys = new Uint8ClampedArray(size);
        for (let i = 0; i < size; i++) {
            let red = imageBuffer[i * 4];
            let doubleGreen = imageBuffer[i * 4 + 1] * 2;
            let blue = imageBuffer[i * 4 + 2];
            greys[i] = (red + doubleGreen + blue) / 4;
        }
        return greys;
    }

    exports.scanQrCodeImpl = left => right => qrcode => rgbaBuffer => width => height => {
        const code = jsQR(rgbaBuffer, width, height);
        if (code) {
            return right(qrcode({ text: code.data, dataBuffer: code.binaryData }));
        } else {
            return left("QR code could not be read");
        }
    };

    exports.scanBarcodeImpl = left => right => barcode => rgbaBuffer => width => height => {
        try {
            const res = scanBarcode(rgbaBuffer, width, height);
            return right(barcode(res.text));
        } catch (err) {
            return left(err.message);
        }
    };
})(PS.QrReader = PS.QrReader || {});
(function ($PS) {
    // Generated by purs version 0.14.4
    "use strict";

    $PS.QrReader = $PS.QrReader || {};
    var exports = $PS.QrReader;
    var $foreign = $PS.QrReader;
    var Data_Either = $PS["Data.Either"];
    var QrCode = function () {
        function QrCode(value0) {
            this.value0 = value0;
        };
        QrCode.create = function (value0) {
            return new QrCode(value0);
        };
        return QrCode;
    }();
    var Barcode = function () {
        function Barcode(value0) {
            this.value0 = value0;
        };
        Barcode.create = function (value0) {
            return new Barcode(value0);
        };
        return Barcode;
    }();
    var showCode = {
        show: function (v) {
            if (v instanceof Barcode) {
                return "Barcode { " + (v.value0 + " }");
            };
            if (v instanceof QrCode) {
                return "QrCode { " + (v.value0.text + " }");
            };
            throw new Error("Failed pattern match at QrReader (line 24, column 1 - line 27, column 52): " + [v.constructor.name]);
        }
    };
    var scanQrCode = function (rgbaBuffer) {
        return function (width) {
            return function (height) {
                return $foreign.scanQrCodeImpl(Data_Either.Left.create)(Data_Either.Right.create)(QrCode.create)(rgbaBuffer)(width)(height);
            };
        };
    };
    var scanBarcode = function (rgbaBuffer) {
        return function (width) {
            return function (height) {
                return $foreign.scanBarcodeImpl(Data_Either.Left.create)(Data_Either.Right.create)(Barcode.create)(rgbaBuffer)(width)(height);
            };
        };
    };
    var eqCode = {
        eq: function (v) {
            return function (v1) {
                if (v instanceof Barcode && v1 instanceof Barcode) {
                    return v.value0 === v1.value0;
                };
                if (v instanceof QrCode && v1 instanceof QrCode) {
                    return v.value0.text === v1.value0.text;
                };
                return false;
            };
        }
    };
    exports.scanBarcode = scanBarcode;
    exports.scanQrCode = scanQrCode;
    exports.QrCode = QrCode;
    exports.Barcode = Barcode;
    exports.eqCode = eqCode;
    exports.showCode = showCode;
})(PS);
var _default = PS.QrReader;
export { _default as __reserved_default };
