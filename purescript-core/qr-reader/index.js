// Generated by purs bundle 0.14.4
var PS = {};
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Data.Either"] = $PS["Data.Either"] || {};
  var exports = $PS["Data.Either"];                
  var Left = (function () {
      function Left(value0) {
          this.value0 = value0;
      };
      Left.create = function (value0) {
          return new Left(value0);
      };
      return Left;
  })();
  var Right = (function () {
      function Right(value0) {
          this.value0 = value0;
      };
      Right.create = function (value0) {
          return new Right(value0);
      };
      return Right;
  })();
  exports["Left"] = Left;
  exports["Right"] = Right;
})(PS);
(function(exports) {
  "use strict";

  const { MultiFormatReader, RGBLuminanceSource, BinaryBitmap, HybridBinarizer, DecodeHintType, BarcodeFormat } = require('@zxing/library');
  const jsQR = require('jsqr');
  const qrCodeGenerator = require('qrcode-generator');

  function scanBarcode(rgbaBuffer, width, height) {
      const hints = new Map();
      const formats = [BarcodeFormat.EAN_13, BarcodeFormat.EAN_8];
      hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);
      const reader = new MultiFormatReader(hints);
      const luminances = toGrayscaleBuffer(rgbaBuffer, width, height);
      const luminanceSource = new RGBLuminanceSource(luminances, width, height);
      const binaryBitmap = new BinaryBitmap(new HybridBinarizer(luminanceSource));
      return reader.decode(binaryBitmap);
  }

  function toGrayscaleBuffer(imageBuffer, width, height) {
      /*Zxing works with grayscale images. They use a green-favoring average:
    https://github.com/zxing/zxing/blob/be2c5bdd883f9f42e794e4b0e7e1b30f436fc0a7/core/src/main/java/com/google/zxing/RGBLuminanceSource.java#L42-L56
    */  
      const size = width * height;
      let greys = new Uint8ClampedArray(size);
      for (let i = 0; i < size; i++) {
          let red = imageBuffer[i * 4];
          let doubleGreen = imageBuffer[i * 4 + 1] * 2;
          let blue = imageBuffer[i * 4 + 2];
          greys[i] = (red + doubleGreen + blue) / 4;
      }
      return greys;
  }

  exports.scanQrCodeImpl = left => right => qrcode => rgbaBuffer => width => height => {
      const code = jsQR(rgbaBuffer, width, height);
      if (code) {
          return right(qrcode(code.data));
      } else {
          return left("QR code could not be read");
      }
  }

  exports.scanBarcodeImpl = left => right => barcode => rgbaBuffer => width => height => {
      try {
          const res = scanBarcode(rgbaBuffer, width, height);
          return right(barcode(res.text));
      } catch (err) {
          return left("Barcode could not be read");
      }
  }

  exports.createBase64PNGQrCodeImpl = text => size => {
      const qr = qrCodeGenerator(0, 'L');
      qr.addData(text);
      qr.make();
      const qrModuleSize = size / (qr.getModuleCount() + 8);
      const margin = 4 * qrModuleSize;
      const base64GifQrImage = qr.createDataURL(qrModuleSize, margin);
      return base64GifQrImage.replace("data:image/gif", "data:image/png");
  }
})(PS["QrReader"] = PS["QrReader"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["QrReader"] = $PS["QrReader"] || {};
  var exports = $PS["QrReader"];
  var $foreign = $PS["QrReader"];
  var Data_Either = $PS["Data.Either"];                
  var QrCode = (function () {
      function QrCode(value0) {
          this.value0 = value0;
      };
      QrCode.create = function (value0) {
          return new QrCode(value0);
      };
      return QrCode;
  })();
  var Barcode = (function () {
      function Barcode(value0) {
          this.value0 = value0;
      };
      Barcode.create = function (value0) {
          return new Barcode(value0);
      };
      return Barcode;
  })();
  var showCode = {
      show: function (v) {
          if (v instanceof Barcode) {
              return "Barcode { " + (v.value0 + " }");
          };
          if (v instanceof QrCode) {
              return "QrCode { " + (v.value0 + " }");
          };
          throw new Error("Failed pattern match at QrReader (line 20, column 1 - line 23, column 47): " + [ v.constructor.name ]);
      }
  };
  var scanQrCode = function (rgbaBuffer) {
      return function (width) {
          return function (height) {
              return $foreign.scanQrCodeImpl(Data_Either.Left.create)(Data_Either.Right.create)(QrCode.create)(rgbaBuffer)(width)(height);
          };
      };
  };
  var scanBarcode = function (rgbaBuffer) {
      return function (width) {
          return function (height) {
              return $foreign.scanBarcodeImpl(Data_Either.Left.create)(Data_Either.Right.create)(Barcode.create)(rgbaBuffer)(width)(height);
          };
      };
  };
  var eqCode = {
      eq: function (v) {
          return function (v1) {
              if (v instanceof Barcode && v1 instanceof Barcode) {
                  return v.value0 === v1.value0;
              };
              if (v instanceof QrCode && v1 instanceof QrCode) {
                  return v.value0 === v1.value0;
              };
              return false;
          };
      }
  };
  var createBase64PNGQrCode = $foreign.createBase64PNGQrCodeImpl;
  exports["scanBarcode"] = scanBarcode;
  exports["scanQrCode"] = scanQrCode;
  exports["QrCode"] = QrCode;
  exports["Barcode"] = Barcode;
  exports["createBase64PNGQrCode"] = createBase64PNGQrCode;
  exports["eqCode"] = eqCode;
  exports["showCode"] = showCode;
})(PS);
module.exports = PS["QrReader"];
